https://vjudge.net/problem/UVA-10911

Español:
Hay 2N estudiantes, se quieren hacer N grupos.
Si se suma la distancia de cada grupo formado, el total tiene que ser lo mínimo posible.

Se puede hacer con backtracking, si se toma un estudiante, se forma un grupo con cada estudiante
disponible, en cada agrupación se hace una nueva llamada recursiva y se repite el proceso.

El problema de esto es que hay muchos posibles candidatos en el conjunto de soluciones, si se
toma un estudiante, hay 15 opciones, luego de que se tome una opción, el siguiente estudiante 
tendrá 13 opciones, y así sucesivamente. Esto es 15*13*11*...*1 = 15!! (El doble factorial es
el factorial simple pero saltando de dos en dos).

Para hacer el problema más rápidamente, se puede usar dp. La idea sería la siguiente:
Imaginemos el caso {1,1},{8,6},{6,8},{1,3}.

Si hacemos un enfoque de dp top-down, empezando desde el problema más grande, tendríamos una
función tal que así:

optimal({1,1},{8,6},{6,8},{1,3}) = min(
    dist({1,1},{8,6}) + optimal({6,8},{1,3}),
    dist({1,1},{6,8}) + optimal({8,6},{1,3}),
    dist({1,1},{1,3}) + optimal({8,6},{6,8})
)

Seguimos la llamada recursiva con:

optimal({6,8},{1,3}) = min(
    dist({6,8},{1,3}) + optimal({})
)

De donde, 

optimal({}) = 0;

Y así sucesivamente, el problema se divide de esta manera en subproblemas más simples,
¡Que además se solapan! y hay una subestructura óptima, porque se toma el mínimo en cada
llamada.

Para implementar este problema aparentemente se usa dp con bitmask, no conozco mucho sobre eso,
pero hice un intento de función para ello.